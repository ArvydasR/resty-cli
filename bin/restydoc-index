#!/usr/bin/env perl

use strict;
use warnings;

use FindBin ();
use File::Find ();
use Cwd qw( cwd );
use File::Spec ();

my $indir = shift
    or die "no input project directory name specified.\n";

if (!-d $indir) {
    die "input directory $indir not found.\n";
}

$indir =~ s{/+$}{}g;

(my $full_dist_name = $indir) =~ s{.*/}{};
(my $dist_name = $full_dist_name) =~ s{ [-_] v? ( \d+ (?:\.\d+)* (?: rc\d+ | _\d+ )? ) $ }{}i;
$dist_name = lc $dist_name;
my $dist_ver = $1;

#print "name: $full_dist_name\n";
#if (defined $dist_ver) {
    #print "version: $dist_ver\n";
#}

my @aliases = gen_aliases($indir, $dist_name);
#print "aliases: @aliases\n";

my $poddir = "$FindBin::Bin/../pod";

if (!-d $poddir) {
    mkdir $poddir
        or die "failed to create $poddir: $!\n";
}

my @dist_modules;

File::Find::find(\&wanted,  $indir);

my $index = "dist $dist_name\n";

if ($dist_ver) {
    $index .= "  version $dist_ver\n";
}

if (@aliases) {
    $index .= "  aliases @aliases\n";
}

if (@dist_modules) {
    my @names = map { lc($_->{name}) } @dist_modules;
    $index .= "  modules " . join(" ", @names) . "\n";
}

$index .= "\n";

my $index_file = "resty.index";
open my $out, ">>$index_file"
    or die "cannot open $index_file for appending: $!\n";
print $out $index;
close $out;

sub wanted {
    return unless -f $_ && m/ \. (?: md | markdown) $ /x;
    my $mdfile = $File::Find::name;

    my $name = File::Spec->abs2rel($mdfile, $indir);
    return if $name =~ /^node_modules/i;

    $name = lc $name;
    $name =~ s{ ^ (?: lib | src | lua ) / }{}x;
    $name =~ s{ \. \w+ $ }{}x;
    $name =~ s{/}{.}g;

    return if length($name) == 1;

    #warn $name;
    #warn "wanted: $File::Find::dir $File::Find::name $_\n";
    if ($name =~ / ^ README $ /xi) {
        $name = $dist_name;
    }

    my $podfile = "$poddir/$name.pod";
    shell("$FindBin::Bin/md2pod.pl -o $podfile $mdfile");

    my $dist_module = process_pod($podfile, $name);

    push @dist_modules, $dist_module;
}

sub process_pod {
    my ($infile, $name) = @_;

    my $dist_module = {
        name => $name,
    };

    open my $in, "<:encoding(UTF-8)", $infile or
        die "cannot open $infile for reading: $!\n";

    my ($toc_level, $new);
    while (<$in>) {
        if (defined $toc_level) {
            if (/ ^ =head (\d+) /x && $1 >= $toc_level) {
                undef $toc_level;
                next;
            }

            # ignore the content
            next;
        }

        # !defined $level

        if (/ ^ =head (\d+) \s+ Table \s+ of \s+ Contents? \s* $ /ix) {
            $toc_level = $1;
            # ignore the content
            next;
        }

        $new .= $_;
    }

    close $in;

    open my $out, ">:encoding(UTF-8)", $infile
        or die "cannot open $infile for writing: $!\n";
    print $out $new;
    close $out;

    return $dist_module;
}

sub shell {
    my $cmd = shift;

    #warn $cmd;
    system($cmd) == 0
        or die "failed to run command \"$cmd\": $!\n";
}

sub gen_aliases {
    my ($indir, $name) = @_;

    my @aliases;
    if ($name =~ s/-nginx-module$//) {
        $name =~ s/-/_/g;
        $name = "ngx_" . $name;
        push @aliases, $name;
    }

    if ($name =~ / ^ lua (?: - \w+ )+ $ /x) {
        $name =~ s/^lua-//;
        $name =~ s/-/./g;
        push @aliases, $name;
    }

    my $config_file = "$indir/config";
    if (-f $config_file) {
        open my $in, $config_file
            or die "cannot open $config_file for reading: $!\n";
        while (<$in>) {
            if (/ \b ngx_addon_name = .*? (\w+) /x) {
                my $addon = lc $1;
                push @aliases, $addon;
                last;
            }
        }
        close $in;
    }

    return @aliases;
}
